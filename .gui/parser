#0

#1
view "Metadata" {
  raw 0;
  raw 1;
}

view "BUILD" {
  raw 2;
}

view "lowering-spec" {
  raw 3;
  raw 4;
}

view "parser-spec" {
  raw 5;
  raw 6;
}
#2
buf_parser lowering_spec {
  parser = 3;
  tokens = 4;
  gen_dir = ".generated/gen/parser";
  cc_out = "lowering_spec.cc";
  h_out = "lowering_spec.h";
}
buf_parser parser_spec {
  parser = 5;
  tokens = 6;
  gen_dir = ".generated/gen/parser";
  cc_out = "parser-spec.cc";
  h_out = "parser-spec.h";
}
buf_parser tokenizer_spec {
  parser = 7;
  tokens = 8;
  gen_dir = ".generated/gen/parser";
  cc_out = "tokenizer-spec.cc";
  h_out = "tokenizer-spec.h";
}
#3
module lowering_spec;

tokenizer basic;
entry Module;

expr TypeRef {
  pattern Void { "unit" }
  pattern Member { %base = _ "::" %name = identifier }
  pattern Named { %name = identifier }
  pattern Template { %base = _ "<" %args = concat { TypeRef } ">" }
}

expr Expr {
  pattern New { "new" %type = TypeRef %body = CompoundStmt }
  pattern Number { %value = number }
  pattern Str { %value = str }
  pattern Dot { %base = _ "." %name = identifier }
  pattern Arrow { %base = _ "->" %name = identifier }
  pattern Named { %name = identifier }
  pattern Index { %base = _ "[" %args = comma_array(comma) { Expr } "]" }
  pattern ColonColon { %base = _ "::" %name = identifier }
  pattern Call { %base = _ "(" %args = comma_array(comma) { Expr } ")" }
  left {
    pattern CompEqEq { %lhs = _ "==" %rhs = _ }
  }
  right {
    pattern Assign { %lhs = _ "=" %rhs = _ }
  }
}

production CompoundStmt: Stmt {
  pattern Compound { "{" %stmts = concat { Stmt } "}" }
}

production Stmt {
  pattern ReturnVoid { "return" ";" }
  pattern Return { "return" %expr = Expr ";" }
  pattern Let { "let" %name = identifier "=" %expr = Expr ";" }
  pattern Var { "var" %name = identifier ":" %type = TypeRef ";" }
  pattern OpenWithType { "open" %name = identifier ":" %type = TypeRef %body = CompoundStmt }
  pattern Open { "open" %name = identifier %body = CompoundStmt }
  pattern Case { "case" "." %name = identifier ":" }
  pattern For { "for" %name = identifier "in" %sequence = Expr %body = CompoundStmt }
  pattern Loop { "loop" %body = CompoundStmt }
  pattern IfElse { "if" "(" %cond = Expr ")" %body = CompoundStmt "else" %else_body = CompoundStmt }
  pattern If { "if" "(" %cond = Expr ")" %body = CompoundStmt }
  pattern Scope { "scope" %name = identifier "=" %expr = Expr %body = CompoundStmt }
  pattern Default { "default" ":" }
  pattern Emitter { "emit" %body = CompoundStmt }
  pattern DbgEmitter { "dbg_emit" %body = CompoundStmt }
  pattern Break { "break" ";" }
  pattern Discard { %expr = Expr ";" }
}

define FuncArg {
  %name = identifier ":" %type = TypeRef 
}

production Decl {
  pattern Context { "context" %name = identifier ":" %type = TypeRef ";" }
  pattern Func { "func" %name = identifier
  "(" %args = comma_array(comma) { FuncArg} ")"
  "->" %ret_t = TypeRef %body = CompoundStmt }
}

define Module {
  "module" %mod_name = identifier ";"
  %decls = concat { Decl }
}
#4
module unused;

regex basic {
  let digit = "0" : "9";
  let id = ("a" : "z") | "_" | ("A" : "Z");
  let all = (" " : "~");
  emit dot = ".";
  emit plus = "+";
  emit pipe = "|";
  emit star = "*";
  emit semi = ";";
  emit comma = ",";
  emit equal = "=";
  emit equalequal = "==";
  emit notequal = "!=";
  emit open_arr = "<";
  emit close_arr = ">";
  emit open_paran = "(";
  emit close_paran = ")";
  emit open_brace = "{";
  emit close_brace = "}";
  emit open_bracket = "[";
  emit close_bracket = "]";
  emit percent = "%";
  emit arrow = "->";
  emit colon = ":";
  emit coloncolon = "::";
  emit eof = 0;
  ignore "\n";
  ignore " ";
  emit identifier = id . (id | digit)*;
  emit str = "\"" . (("\\" . all) | (" " : "!") | ("#" : "[") | ("]" : "~"))* . "\"";
  emit number = digit+;
}
#5
module production_spec;

entry Module;
tokenizer basic;

expr TypeDeclExpr {
  pattern Product {
    "(" %decls = comma_array(comma) {
      new TypeLetDecl { %name = identifier ":" %type = TypeDeclExpr}
    } ")" }
  pattern Sum {
    "{" %decls = concat {
      new TypeLetDecl { %name = identifier "=" %type = TypeDeclExpr ";"}
    } "}" }
  pattern Named { %name = identifier }
  pattern Colon { %base = _ "::" %name = identifier }
  pattern Parametric { %base = _ "<" %params = concat { TypeDeclExpr } ">" }
}

production PatternExpr {
  pattern CommaConcat { "comma_array" "(" %comma = identifier ")"
    %element = CompoundPatternStmt }
  pattern Concat { "concat" %element = CompoundPatternStmt }
  pattern Self { "_" }
  pattern New { "new" %type = TypeDeclExpr
    %value = CompoundPatternStmt }
  pattern Pop { "pop" }
  pattern Named { %name = identifier }
}

production CompoundPatternStmt: PatternStmt {
  pattern Compound { "{" %items = concat { PatternStmt } "}" }
}
production PatternStmt {
  pattern String { %value = str }
  pattern Assign { "%" %name = identifier "=" %value = PatternExpr }
  pattern Push { "push" %value = PatternExpr }
  pattern Merge { "merge" "("
  %items = comma_array(comma) { PatternStmt } ")" }
  pattern ExprTailLoop { "expr_tail_loop" "(" %base = PatternExpr ")"
      ":" %type = TypeDeclExpr %value = CompoundPatternStmt }
  pattern Conditional { "try" %value = CompoundPatternStmt }
  pattern Wrap { %value = PatternExpr }
}

pattern DeclList { "{" concat { Decl } "}" }
production Decl {
  pattern Type {"type" %name = identifier "=" %type = TypeDeclExpr ";" }
  pattern Expr { "expr" %name = identifier %stmts = DeclList }
  pattern ProductionAndType {
    "production" %name = identifier ":" %type = TypeDeclExpr
    %stmts = DeclList }
  pattern Production {
    "production" %name = identifier %stmts = DeclList }
  pattern Pattern {
    "pattern" %name = identifier %value = CompoundPatternStmt }
  pattern LeftAssoc { "left" %stmts = DeclList }
  pattern RightAssoc { "right" %stmts = DeclList }
  pattern DefineWithType {
    "define"  %name = identifier ":" %type = TypeDeclExpr %value = CompoundPatternStmt }
  pattern Define {
    "define"  %name = identifier %value = CompoundPatternStmt }
  pattern Entry { "entry" %name = identifier ";" }
  pattern Tokenizer { "tokenizer" %name = identifier ";" }
}

define Module {
  "module" %mod_name = identifier ";"
  %decls = concat { Decl }
}
#6
module example;

regex basic {
  let digit = "0" : "9";
  let id = ("a" : "z") | "_" | ("A" : "Z");
  let all = (" " : "~");
  emit dot = ".";
  emit plus = "+";
  emit pipe = "|";
  emit star = "*";
  emit semi = ";";
  emit comma = ",";
  emit equal = "=";
  emit open_arr = "<";
  emit close_arr = ">";
  emit open_paran = "(";
  emit close_paran = ")";
  emit open_brace = "{";
  emit close_brace = "}";
  emit percent = "%";
  emit arrow = "->";
  emit colon = ":";
  emit coloncolon = "::";
  emit eof = 0;
  ignore "\n";
  ignore " ";
  emit identifier = id . (id | digit)*;
  emit str = "\"" . (("\\" . all) | (" " : "!") | ("#" : "[") | ("]" : "~"))* . "\"";
  emit number = digit+;
}
#7
module parser_spec;
tokenizer basic;
entry Module;


type Edge = {
  Range = (start: char, end: char, next: Node);
  Unary = (match: char, next: Node);
  SkipTo = (next: Node);
  Emit = (name: Token);
  Ignore = ();
  Unexpected = ();
};

expr RegexExpr {
  pattern Integer { %value = number }
  pattern String { %value = str }
  left { pattern Range { %st = _ ":" %ed = _ } }
  pattern Named { %name = identifier }
  pattern Wrapped { "(" %value = RegexExpr ")" }
  pattern Star { %base = _ "*" }
  pattern Plus { %base = _ "+" }
  left { pattern Juxta { %lhs = _ "." %rhs = _ } }
  left { pattern Alt { %lhs = _ "|" %rhs = _ } }
}

production TokenDecl {
  pattern Let { "let" %name = identifier "=" %value = RegexExpr ";" }
  pattern Emit { "emit" %name = identifier "=" %value = RegexExpr ";" }
  pattern Ignore { "ignore" %value = RegexExpr ";" }
  pattern Import { "import" %module = identifier "." %name = identifier ";" }
}

production Edge {
}

define Node {
  %edges = concat { Edge }
}

type NodePair = (st: Node, ed: Node);

production Decl {
  pattern Regex { "regex" %name = identifier "{" %items = concat { TokenDecl } "}" }
  pattern NFAGraph { "nfa_grap" %name = identifier "=" %root = Node ";" }
}

define Module {
  "module" %mod_name = identifier ";"
  %decls = concat { Decl }
}
#8
module example;

regex basic {
  let digit = "0" : "9";
  let id = ("a" : "z") | "_" | ("A" : "Z");
  let all = (" " : "~");
  emit dot = ".";
  emit plus = "+";
  emit pipe = "|";
  emit star = "*";
  emit semi = ";";
  emit comma = ",";
  emit equal = "=";
  emit open_arr = "<";
  emit close_arr = ">";
  emit open_paran = "(";
  emit close_paran = ")";
  emit open_brace = "{";
  emit close_brace = "}";
  emit percent = "%";
  emit arrow = "->";
  emit colon = ":";
  emit coloncolon = "::";
  emit eof = 0;
  ignore "\n";
  ignore " ";
  emit identifier = id . (id | digit)*;
  emit str = "\"" . (("\\" . all) | (" " : "!") | ("#" : "[") | ("]" : "~"))* . "\"";
  emit number = digit+;
}
