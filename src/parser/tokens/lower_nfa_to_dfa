module parser_spec;

func visitSuccessors(ctx: DFAMappingContext, base: Node, states: Array<Node>) -> unit {
  let c_ctx = new EdgeSetContext {};
  for state in states { c_ctx->AddWork(state); }
  loop {
    if (c_ctx->work_list.empty()) { break; }
    let node = c_ctx->work_list.back();
    c_ctx->work_list.pop_back();
    for e in node->edges {
      open e : Edge {
      case .Range: c_ctx->add_edge(e->start, e->end, e->next);
      case .Unary: c_ctx->add_edge(e->match, e->match, e->next);
      case .SkipTo: c_ctx->AddWork(e->next);
      case .Emit: c_ctx->SetEmitOrIgnore(e);
      case .Ignore: c_ctx->SetEmitOrIgnore(e);
      case .Unexpected: error(e);
      }
    }
  }
  for edge in c_ctx->edges {
    let next = ctx->getNode(Canonicalize(edge.next));
    if (edge.st == edge.ed) {
      base->edges.push_back(new UnaryEdge { self->next = next; self->match = edge.ed; });
    } else {
      base->edges.push_back(new RangeEdge { self->next = next; self->start = edge.st; self->end = edge.ed; });
    }
  }
  if (c_ctx->emit_or_ignore) {
    base->edges.push_back(c_ctx->emit_or_ignore);
  } else {
    base->edges.push_back(new UnexpectedEdge {});
  }
}

func toDFA(root: Node) -> Node {
  let ctx = new DFAMappingContext {};
  var states: Array<Node>;
  states.push_back(root);
  let result = ctx->getNode(states);
  loop {
    if (ctx->work_list.empty()) { break; }
    let item = ctx->work_list.back();
    ctx->work_list.pop_back();
    visitSuccessors(ctx, item.first, item.second);
  }
  return result;
}
