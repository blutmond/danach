module lower_regex_to_nfa;

context let_context : NameDeclMap<RegexDecl>;

func skip(a: Node, b: Node) -> unit { a->edges.push_back(new SkipToEdge { self->next = b; }); }

func lowerToChar(e: RegexExpr) -> char {
  open e : RegexExpr {
  case .String:
    let tmp = Unescaped(e->value.str);
    assert(tmp.size() == 1, e->value, " is not a single char");
    return tmp[0];
  case .Integer:
    let tmp = fromString(e->value.str);
    assert(isChar(tmp), e->value, " out of range [0, 255]");
    return tmp;
  default:
    error(e, "is not a single char");
  }
}
func lower(ctx: LetContext, e: RegexExpr) -> NodePair {
  open e : RegexExpr {
  case .String:
    let n = new Node {};
    let pair = new NodePair { self->st = n; self->ed = n; };
    for c in Unescaped(e->value.str) {
      let edge = new UnaryEdge {};
      edge->match = c;
      edge->next = new Node {};
      pair->ed->edges.push_back(edge);
      pair->ed = edge->next;
    }
    return pair;
  case .Integer:
    let pair = new NodePair { self->st = new Node {}; self->ed = new Node {}; };
    let edge = new UnaryEdge {};
    pair->st->edges.push_back(edge);
    edge->match = lowerToChar(e);
    edge->next = pair->ed;
    return pair;
  case .Range:
    let pair = new NodePair { self->st = new Node {}; self->ed = new Node{}; };
    let edge = new RangeEdge {};
    pair->st->edges.push_back(edge);
    edge->start = lowerToChar(e->st);
    edge->end = lowerToChar(e->ed);
    edge->next = pair->ed;
    return pair;
  case .Juxta:
    let a = lower(ctx, e->lhs);
    let b = lower(ctx, e->rhs);
    skip(a->ed, b->st);
    return new NodePair { self->st = a->st; self->ed = b->ed; };
  case .Wrapped: return lower(ctx, e->value);
  case .Named: return lower(ctx, ctx->find(e->name.str));
  case .Alt:
    let pair = new NodePair { self->st = new Node{}; self->ed = new Node{}; };
    let a = lower(ctx, e->lhs);
    let b = lower(ctx, e->rhs);
    skip(pair->st, a->st);
    skip(pair->st, b->st);
    skip(a->ed, pair->ed);
    skip(b->ed, pair->ed);
    return pair;
  case .Star:
    let pair = new NodePair { self->st = new Node{}; self->ed = new Node {}; };
    let a = lower(ctx, e->base);
    skip(a->ed, a->st);
    skip(pair->st, a->st);
    skip(a->ed, pair->ed);
    skip(pair->st, pair->ed);
    return pair;
  case .Plus:
    let a = lower(ctx, e->base);
    skip(a->ed, a->st);
    return a;
  }
}

func rewriteRegexDecl(decl: RegexDecl) -> NFAGraphDecl {
  scope ctx = new LetContext {} {
    return new NFAGraphDecl {
      self->name = decl->name;
      self->root = new Node {};
      for i in decl->items {
        open i : TokenDecl {
        case .Let: ctx->declare(i->name.str, i->value);
        case .Import: error("import not supported right now");
        case .Emit:
          let nfa = lower(ctx, i->value);
          skip(self->root, nfa->st);
          nfa->ed->edges.push_back(new EmitEdge { self->name = i->name; });
        case .Ignore:
          let nfa = lower(ctx, i->value);
          skip(self->root, nfa->st);
          nfa->ed->edges.push_back(new IgnoreEdge {});
        }
      }
    };
  }
}
