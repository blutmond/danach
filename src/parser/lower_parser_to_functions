module production_spec;

func doModuleTypeCheck(globals: ModuleContext, m: Module) -> unit {
  for decl in m->decls {
    open decl : Decl {
    case .DefineWithType:
      globals->RegisterForTypeChecking(decl);
    case .Type:
      globals->RegisterType(decl);
    default:
    }
  }
  globals->typeCheckAll();
}

func getTokenizerName(m: Module) -> String {
  for d in m->decls {
    open d: Decl {
    case .Tokenizer: return d->name.str;
    default:
    }
  }
  return "";
}

func DebugPrintType(t: TypeDeclExpr) -> unit {
  open t: TypeDeclExpr {
  case .Product:
    dbg_emit { "Invalid"; }
  case .Sum:
    dbg_emit { "Invalid"; }
  case .Named:
    dbg_emit { t->name.str; }
  case .Colon:
    DebugPrintType(t->base);
    dbg_emit { "::"; t->name.str; }
  case .Parametric:
    DebugPrintType(t->base);
    dbg_emit { "<"; }
    let notfirst = false;
    for param in t->params {
      if (notfirst) { dbg_emit { ", "; } }
      notfirst = true;
      DebugPrintType(param);
    }
    dbg_emit { ">"; }
  }
}

func DebugPrintExpr(e: PatternExpr) -> unit {
  open e: PatternExpr {
    case .Named:
      dbg_emit { e->name.str; }
    case .New:
      dbg_emit { "new "; }
      DebugPrintType(e->type);
      dbg_emit { " "; }
      DebugPrintStmt(e->value);
    case .Pop:
      dbg_emit{ "pop"; }
    default:
      dbg_emit { "Unknown"; }
  }
}

func DebugPrintStmt(s: PatternStmt) -> unit {
  open s: PatternStmt {
  case .String:
    dbg_emit { s->value.str; }
  case .Assign:
    dbg_emit { "%"; s->name.str; " = "; } DebugPrintExpr(s->value);
  case .Push:
    dbg_emit { "push "; } DebugPrintExpr(s->value);
  case .ExprTailLoop:
    dbg_emit { "expr_tail_loop("; }
    DebugPrintExpr(s->base);
    dbg_emit { ")"; }
    DebugPrintStmt(s->value);
  case .Conditional:
    dbg_emit { "try "; } DebugPrintStmt(s->value); dbg_emit {"\n"; }
  case .Merge:
    dbg_emit { "merge?"; }
  case .Wrap:
    DebugPrintExpr(s->value);
  case .Compound:
    dbg_emit { "{"; }
    dbg_emit { "\n"; }
    for item in s->items { DebugPrintStmt(item); }
    dbg_emit { "\n"; }
    dbg_emit { "}"; }
  }
}

