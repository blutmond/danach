module production_spec;

func productionName(d: DefineWithTypeDecl) -> unit {
  emit { "_production_"; d->name.str; }
}

func getValue(s: PatternStmt) -> PatternExpr {
  open s: PatternStmt {
  case .Assign: return s->value;
  case .Push: return s->value;
  case .Wrap: return s->value;
  default: return nullptr;
  }
}

func findSuccessorForExpr(expr: PatternExpr, stmt: PatternStmt) -> PatternStmt {
  open expr: PatternExpr {
  case .New: return findSuccessor(expr->value);
  case .Named: return stmt;
  case .Pop: return nullptr;
  case .CommaConcat: return stmt;
  case .Concat: return stmt;
  case .Self: return stmt;
  }
}

func findSuccessor(s: PatternStmt) -> PatternStmt {
  open s: PatternStmt {
    case .String: return s;
    case .Merge: return s;
    case .ExprTailLoop: return s;
    case .Conditional: return s;
    case .Compound:
      for stmt in s->items {
        let succ = findSuccessor(stmt);
        if (succ) { return succ; }
      }
      return nullptr;
    case .Wrap: return findSuccessorForExpr(s->value, s);
    case .Assign: return findSuccessorForExpr(s->value, s);
    case .Push: return findSuccessorForExpr(s->value, s);
  }
}

func makeTryStmtFromPattern(subdecl: PatternDecl, base_type: TypeDeclExpr) -> PatternStmt {
  let subt = new ColonTypeDeclExpr {
    self->base = base_type;
    self->name = subdecl->name;
  };
  return new ConditionalPatternStmt {
    self->value = new CompoundPatternStmt {
      self->items.push_back(new WrapPatternStmt {
        self->value = new NewPatternExpr {
          self->type = subt;
          self->value = subdecl->value;
        };
      });
    };
  };
}

func lowerProductionToMergeDecl(m: Module, globals: ModuleContext, d: Decl) -> Decl {
  open d: Decl {
  case .Define:
    return new DefineWithTypeDecl {
      self->name = d->name;
      let type = new NamedTypeDeclExpr { self->name = d->name; };
      self->type = type;
      self->value = new WrapPatternStmt {
        self->value = new NewPatternExpr {
          self->type = type;
          self->value = d->value;
        };
      };
    };
  case .Expr:
    let base_type = new NamedTypeDeclExpr { self->name = d->name; };
    let last_group_name = DoExprAnalysis(m, globals, d, base_type);
    return new DefineWithTypeDecl {
      self->name = d->name;
      self->type = base_type;
      self->value = new CompoundPatternStmt {
        self->items.push_back(new WrapPatternStmt {
          self->value = new NamedPatternExpr {
            self->name = last_group_name;
          };
        });
      };
    };
  case .Production:
    return new DefineWithTypeDecl {
      self->name = d->name;
      let base_type = new NamedTypeDeclExpr { self->name = d->name; };
      self->type = base_type;
      self->value = RotateAndVerifyTrys(globals, new CompoundPatternStmt {
        for subdecl in d->stmts {
          open subdecl: Decl {
          case .Pattern:
            self->items.push_back(makeTryStmtFromPattern(subdecl, base_type));
          default:
            error("Only patterns allowed in exprs...");
          }
        }
      });
    };
  case .ProductionAndType:
    return new DefineWithTypeDecl {
      self->name = d->name;
      let base_type = d->type;
      self->type = base_type;
      self->value = RotateAndVerifyTrys(globals, new CompoundPatternStmt {
        for subdecl in d->stmts {
          open subdecl: Decl {
          case .Pattern:
            self->items.push_back(makeTryStmtFromPattern(subdecl, base_type));
          default:
            error("Only patterns allowed in exprs...");
          }
        }
      });
    };
  case .Pattern:
    return new DefineWithTypeDecl {
      self->name = d->name;
      self->type = nullptr;
      self->value = d->value;
    };
  case .Type: return d;
  case .DefineWithType: return d;
  case .Entry: return d;
  case .Tokenizer: return d;
  default:
    error("Not allowed at top level", d);
  }
}

func lowerProductionToMerge(globals: ModuleContext, m: Module) -> Module {
  return new Module {
    self->mod_name = m->mod_name;
    for decl in m->decls { self->decls.push_back(lowerProductionToMergeDecl(self, globals, decl)); }
  };
}
