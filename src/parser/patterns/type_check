module production_spec;

context tc_ctx: TypeCheckContext;
context field_tc_ctx: FieldTypeCheckContext;

func collectTypeFields(field_tc_ctx: FieldTypeCheckContext, tc_ctx: TypeCheckContext, stmt: PatternStmt) -> unit {
  open stmt: PatternStmt {
  case .Compound:
    for cstmt in stmt->items { collectTypeFields(cstmt); }
  case .Push:
    tc_ctx->Push(doTypeCheckExpr(stmt->value));
  case .String:
  case .Assign:
    field_tc_ctx->setField(stmt->name.str, doTypeCheckExpr(stmt->value));
  default:
    error("stmt not supported: ", stmt);
  }
}

func doTypeCheckExpr(tc_ctx: TypeCheckContext, expr: PatternExpr) -> TypeDeclExpr {
  open expr: PatternExpr {
  case .CommaConcat:
    let globals = tc_ctx->globals;
    let tc_ctx = tc_ctx->ConcatContext();
    let element_ty = globals->CacheType(expr->element, doTypeCheck(expr->element));
    return new ParametricTypeDeclExpr {
      self->base = theArrayType;
      self->params.push_back(element_ty);
    };
  case .Concat:
    let globals = tc_ctx->globals;
    let tc_ctx = tc_ctx->ConcatContext();
    let element_ty = globals->CacheType(expr->element, doTypeCheck(expr->element));
    return new ParametricTypeDeclExpr {
      self->base = theArrayType;
      self->params.push_back(element_ty);
    };
  case .Self:
    return tc_ctx->getSelfType();
  case .New:
    let field_tc_ctx = tc_ctx->newTypeCtx();
    collectTypeFields(expr->value);
    field_tc_ctx->DoVerify(expr->type);
    return expr->type;
  case .Pop:
    return tc_ctx->Pop();
  case .Named:
    if (tc_ctx->globals->isToken(expr->name.str)) {
      return theTokenType;
    }
    return tc_ctx->globals->getType(expr->name.str);
  }
  error("trouble type-checking");
}

func doTypeCheck(tc_ctx: TypeCheckContext, s: PatternStmt) -> TypeDeclExpr {
  open s: PatternStmt {
  case .Wrap:
    return doTypeCheckExpr(s->value);
  case .Compound:
    var type: TypeDeclExpr;
    type = nullptr;
    for stmt in s->items {
       let tmp = doTypeCheck(stmt);
       if (tmp) {
         if (type) {
           DebugPrintStmt(s);
           error("Compound can only have one type", tmp);
         } else {
           type = tmp;
         }
       }
    }
    return type;
  case .Push:
    tc_ctx->Push(doTypeCheckExpr(s->value));
    return nullptr;
  case .Conditional:
    let tc_ctx = tc_ctx->NewConditionalContext();
    doTypeCheck(s->value);
    return nullptr;
  case .ExprTailLoop:
    tc_ctx->Push(s->type);
    doTypeCheck(s->value);
    return nullptr;
  default:
    return nullptr;
  }
}
