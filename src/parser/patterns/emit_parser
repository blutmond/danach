module production_spec;

context emit_ctx: EmitContext;

func emitSanitizedPatternExpr(emit_ctx: EmitContext, expr: PatternExpr) -> unit {
  open expr: PatternExpr {
  case .New:
    emit { "({\n"; }
    emit { "auto __current_self = "; }
    emitNewType(expr->type);
    emit { ";"; }
    emitSanitizedPatternStmt(expr->value);
    emit {
      "__current_self;\n";
      "})";
    }
  case .Named:
    if (emit_ctx->globals->isToken(expr->name.str)) {
      emit { "tokens.expect(tok::"; expr->name.str; ")"; }
    } else {
      emit { "_production_"; expr->name.str; "(tokens)"; }
    }
  case .Pop:
    emit { "_tmp_"; emit_ctx->Pop(); }
  case .CommaConcat:
    let emit_ctx = emit_ctx->ConcatContext();
    let type = emit_ctx->TypeCheck(expr->element);
    emit { "([&]{\n"; "std::vector<"; }
    emitTypeExpr(type);
    emit { "> __current_vector__;\n"; }
    let succ = emit_ctx->GetSuccessor(expr);
    if (succ) {
      open succ: PatternStmt {
      case .String:
        emit {"   if (!tokens.peak_check_str("; succ->value.str; "))"; }
      default:
        error(succ, " must be constant string");
      }
    } else {
      emit { "   if (!tokens.peak_check(tok::eof))"; }
    }
    emit { " {\n"; }
    emit { "    while (true) {\n"; }
    emit { " __current_vector__.push_back([&]{"; }
    emitSanitizedPatternStmt(expr->element);
    emitResultIfPresent();
    emit { " }());"; }
    emit { " if (tokens.peak_check(tok::"; expr->comma.str; ")) {\n"; }
    emit { "   tokens.expect(tok::"; expr->comma.str; ");\n"; }
    emit { " } else { break; }\n"; }
    emit { "  }}return __current_vector__;\n}())\n"; }
  case .Concat:
    let emit_ctx = emit_ctx->ConcatContext();
    let type = emit_ctx->TypeCheck(expr->element);
    emit { "([&]{\n"; "std::vector<"; }
    emitTypeExpr(type);
    emit { "> __current_vector__;\n"; }
    emit { "    while (true) {\n"; }
    let succ = emit_ctx->GetSuccessor(expr);
    if (succ) {
      open succ: PatternStmt {
      case .String:
        emit {"   if (tokens.peak_check_str("; succ->value.str; "))"; }
      default:
        error(succ, " must be constant string");
      }
    } else {
      emit { "   if (tokens.peak_check(tok::eof))"; }
    }
    emit { " { break; }\n"; }
    emit { " __current_vector__.push_back([&]{"; }
    emitSanitizedPatternStmt(expr->element);
    emitResultIfPresent();
    emit { " }());"; }
    emit { "  }\nreturn __current_vector__;\n}())\n"; }
  case .Self:
    emit { "(0 /* unknown expr*/)"; }
  }
}

func emitResultIfPresent(emit_ctx: EmitContext) -> unit {
  if (emit_ctx->has_result) {
    if (emit_ctx->is_inside_expr) {
      emit { "expr_result = result;\ncontinue;\n"; }
    } else {
      emit { "return result;\n"; }
    }
  } else {
    emit { "tokens.unexpected();\n"; }
  }
}

func emitConditionalArg(emit_ctx: EmitContext, expr: PatternExpr) -> unit {
  open expr: PatternExpr {
  case .Named:
    if (emit_ctx->globals->isToken(expr->name.str)) {
      emit { "tokens.peak_check(tok::"; expr->name.str; ")"; }
    } else {
      error("Cannot handle as peak_expr: ", expr, " // not token");
    }
  default:
    error("Cannot handle as peak_expr: ", expr);
  }
}


func emitSanitizedPatternStmt(emit_ctx: EmitContext, s: PatternStmt) -> unit {
  open s: PatternStmt {
  case .String:
    emit { "tokens.expect("; s->value.str; ");\n"; }
  case .Assign:
    emit { "__current_self->"; s->name.str; " = "; }
    emitSanitizedPatternExpr(s->value);
    emit { ";\n"; }
  case .Push:
    let next_id = emit_ctx->Push();
    emit { "auto _tmp_"; next_id; " = "; }
    emitSanitizedPatternExpr(s->value);
    emit { ";\n"; }
  case .Wrap:
    emit_ctx->has_result = true;
    emit { "auto result = "; }
    emitSanitizedPatternExpr(s->value);
    emit { ";\n"; }
  case .Compound:
    emit_ctx->RegisterConcatSuccessors(s->items);
    for stmt in s->items {
      emitSanitizedPatternStmt(stmt);
    }
  case .Conditional:
    let emit_ctx = emit_ctx->NewConditionalContext();
    emit { "if ("; }
    let peak_s = getFirstItem(s->value);
    open peak_s: PatternStmt {
    case .String:
      emit { "tokens.peak_check_str("; peak_s->value.str; ")"; }
    case .Push:
      emitConditionalArg(peak_s->value);
    case .Assign:
      emitConditionalArg(peak_s->value);
    case .ExprTailLoop:
      error("Cannot handle ExprTailLoop as peak_expr: ", peak_s);
    case .Wrap:
      DebugPrintExpr(peak_s->value);
      dbg_emit { "\n"; }
      error("Cannot handle Wrap as peak_expr: ", peak_s);
    default:
      error("Cannot handle as peak_expr: ", peak_s);
    }
    emit { ") {\n"; }
    emitSanitizedPatternStmt(s->value);
    emitResultIfPresent();
    emit { "}\n"; }
  case .Merge:
    error(s, " merge is not supported");
  case .ExprTailLoop:
    let emit_ctx = emit_ctx->NewExprTailLoopContext();
    emitTypeExpr(s->type);
    emit { " expr_result = "; }
    emitSanitizedPatternExpr(s->base);
    emit { ";\n"; }
    emit { "while (true) {\n"; }
    let next_id = emit_ctx->Push();
    emit { "auto _tmp_"; next_id; " = expr_result;"; }
    emitSanitizedPatternStmt(s->value);
    emit { "return expr_result;\n"; }
    emit { "}\n"; }
  }
}

func emitBasics(globals: ModuleContext, m: Module, is_header: bool) -> unit {
  emit { "namespace "; m->mod_name.str; "{\n"; }
  emit { "namespace parser {\n"; }
  for decl in m->decls {
    open decl : Decl {
    case .DefineWithType:
      emitTypeExpr(decl->type);
      emit { " "; }
      productionName(decl);
      emit { "(Tokenizer& tokens);\n"; }
    case .Entry:
      let entry_type = new NamedTypeDeclExpr { self->name = decl->name; };
      emitTypeExpr(entry_type);
      emit { " DoParse(Tokenizer& tokens);\n"; }
    default:
    }
  }

if (is_header) {
} else {
  for decl in m->decls {
    open decl : Decl {
    case .DefineWithType:
      let emit_ctx = EmitContext::makeRoot(globals);
      emitTypeExpr(decl->type);
      emit { " "; }
      productionName(decl);
      emit { "(Tokenizer& tokens) {\n"; }
      emitSanitizedPatternStmt(decl->value);
      emitResultIfPresent();
      emit { "}\n"; }
    case .Entry:
      let entry_type = new NamedTypeDeclExpr { self->name = decl->name; };
      emitTypeExpr(entry_type);
      emit { " DoParse(Tokenizer& tokens) {\n"; }
      emit { "  return _production_"; decl->name.str; "(tokens);\n"; }
      emit { "}\n"; }
    default:
    }
  }
}

  emit { "}  // namespace parser\n"; }
  emit { "}  // namespace "; m->mod_name.str; "\n"; }
}
