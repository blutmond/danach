module production_spec;

func emitNewType(t: TypeDeclExpr) -> unit {
  open t : TypeDeclExpr {
  case .Named:
    if (t->name.str == "Token") { error("Cannot new: ", t); return; }
    if (t->name.str == "Array") { error("Cannot new: ", t); return; }
    if (t->name.str == "Map") { error("Cannot new: ", t); return; }
    if (t->name.str == "String") { error("Cannot new: ", t); return; }
    if (t->name.str == "char") { error("Cannot new: ", t); return; }
    if (t->name.str == "int") { error("Cannot new: ", t); return; }
    if (t->name.str == "bool") { error("Cannot new: ", t); return; }
    emit { "new "; t->name.str; }
  case .Colon:
    let sub_t = t->base;
    open sub_t : TypeDeclExpr {
    case .Named:
      emit {"new "; t->name.str; sub_t->name.str; }
    default:
      error("Cannot new: ", t);
    }
  default:
    error("Cannot new: ", t);
  }
}

func emitTypeExpr(t: TypeDeclExpr) -> unit {
  open t : TypeDeclExpr {
  case .Parametric:
    emitTypeExpr(t->base);
    emit { "<"; }
    let notfirst = false;
    for param in t->params {
      if (notfirst) { emit { ", "; } }
      notfirst = true;
      emitTypeExpr(param);
    }
    emit { ">"; }
  case .Named:
    if (t->name.str == "Token") { emit { "tok::Token"; } return; }
    if (t->name.str == "Array") { emit { "std::vector"; } return; }
    if (t->name.str == "Map") { emit { "std::map"; } return; }
    if (t->name.str == "String") { emit { "string_view"; } return; }
    if (t->name.str == "char") { emit { "char"; } return; }
    if (t->name.str == "int") { emit { "int"; } return; }
    if (t->name.str == "bool") { emit { "bool"; } return; }
    emit { t->name.str; "*"; }
  case .Colon:
    let sub_t = t->base;
    open sub_t : TypeDeclExpr {
    case .Named:
      emit {t->name.str; sub_t->name.str; "*"; }
    default:
      error("Do not understand: ", t);
    }
  default:
    error("Do not understand: ", t);
  }
}

func emitStructBody(t: ProductTypeDeclExpr) -> unit {
  for subdecl in t->decls {
    emit { "  "; }
    emitTypeExpr(subdecl->type);
    emit { " "; subdecl->name.str; ";\n"; }
  }
}

func ImplicitDumpTypes(m: Module) -> unit {
  emit { "namespace "; m->mod_name.str; "{\n"; }
  for decl in m->decls {
    open decl : Decl {
    case .Type:
      emit { "struct "; decl->name.str; ";\n"; }
      let type = decl->type;
      open type : TypeDeclExpr {
      case .Sum:
        for subdecl in type->decls {
          emit { "struct "; subdecl->name.str; decl->name.str; ";\n"; }
        }
      default:
      }
    default:
    }
  }

  for decl in m->decls {
    open decl: Decl {
    case .Type:
      let type = decl->type;
      open type : TypeDeclExpr {
      case .Sum:
        emit { "\nstruct "; decl->name.str; " {\n"; }
        emit { "  enum class Kind {\n   "; }
        for subdecl in type->decls { emit { " "; subdecl->name.str; ","; } }
        emit {
          "\n  };\n";
          "  "; decl->name.str; "(Kind kind) : kind_(kind) {}\n";
          " Kind getKind() { return kind_; }\n";
          " private:\n";
          "  Kind kind_;\n";
          "};\n";
        }
        for subdecl in type->decls {
          let subt = subdecl->type;
          open subt : TypeDeclExpr {
          case .Product:
            emit {
              "\nstruct "; subdecl->name.str; decl->name.str; ": public "; decl->name.str; " {\n";
              "  "; subdecl->name.str; decl->name.str; "()";
              " : "; decl->name.str; "(Kind::"; subdecl->name.str; ") {}\n";
            }
            emitStructBody(subt);
            emit { "};\n"; }
          default:
            error("Do not understand: ", t);
          }
        }
      case .Product:
        emit { "\nstruct "; decl->name.str; " {\n"; }
        emitStructBody(type);
        emit { "};\n"; }
      default:
        error("Do not understand: ", t);
      }
    default:
    }
  }

  emit { "}  // namespace "; m->mod_name.str; "\n"; }
}
