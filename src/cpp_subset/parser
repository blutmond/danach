module cpp_subset;

type FnExprItem = {
  Str = (value: Token);
  Slot = ();
};

type Decl = {
  InlineCpp = (value: Token);
  KnownCppType = (name: Token, value: Token);
  FnExpr = (name: Token, items: Array<FnExprItem>);
  KnownTemplate = (name: Token);
  RawFunc = (name: Token, args: Array<FuncArg>, ret_t: TypeRef, body: Stmt);
};

type Module = (
  decls: Array<Decl>
);

type TypeRef = {
  Named = (name: Token);
  Template = (base: TypeRef, args: Array<TypeRef>);
  Void = ();
};

type FuncArg = (
  name: Token,
  type: TypeRef
);

type Expr = {
  Named = (name: Token);
  InlineCpp = (value: Token);
  Dot = (base: Expr, name: Token);
  IntegerLiteral = (value: Token);
  StringLiteral = (value: Token);
  Call = (base: Expr, args: Array<Expr>);
};

type Stmt = {
  Case = (cond: Expr, true_stmt: Stmt, false_stmt: Stmt);
  Var = (name: Token, type: TypeRef);
  Break = ();
  Loop = (body: Stmt);
  VarCall = (name: Token, type: TypeRef, args: Array<Expr>);
  VarAssign = (name: Token, type: TypeRef, value: Expr);
  Return = (expr: Expr);
  Discard = (expr: Expr);
  Compound = (stmts: Array<Stmt>);
};

raw_func ParseFnExprItem() -> FnExprItem {
  if peak() == str {
    return new StrFnExprItem { value = expect(str); };
  } else if peak() == "_" {
    return new SlotFnExprItem { ignore expect(identifier); };
  } else {
    unexpected();
  }
}

raw_func ParseLiteralExpr() -> Expr {
  if peak() == "inline_cpp" {
    ignore expect(identifier);
    return new InlineCppExpr {
      ignore expect(open_paran);
      value = expect(str);
      ignore expect(close_paran);
    };
  } else if peak() == identifier {
    return new NamedExpr { name = expect(identifier); };
  } else if peak() == number {
    return new IntegerLiteralExpr { value = expect(number); };
  } else if peak() == str {
    return new StringLiteralExpr { value = expect(str); };
  } else {
    unexpected();
  }
}

raw_func ParseExpr() -> Expr {
  let expr: Expr = ParseLiteralExpr();
  loop {
    if peak() == open_paran {
      hackset expr = new CallExpr {
        base = expr;
        ignore expect(open_paran);
        args = comma_array(Expr, comma, close_paran) { return ParseExpr(); };
        ignore expect(close_paran);
      };
    } else if peak() == dot {
      hackset expr = new DotExpr {
        base = expr;
        ignore expect(dot);
        name = expect(identifier);
      };
    } else {
      return expr;
    }
  }
}

raw_func ParseIfStmt() -> Stmt {
  return new CaseStmt {
    ignore expect(open_paran);
    cond = ParseExpr();
    ignore expect(close_paran);
    true_stmt = ParseCompoundStmt();
    if peak() == "else" {
      ignore expect(identifier);
      if peak() == "if" {
        ignore expect(identifier);
        false_stmt = ParseIfStmt();
      } else {
        false_stmt = ParseCompoundStmt();
      }
    } else {
      false_stmt = new CompoundStmt {};
    }
  };
}

raw_func ParseStmt() -> Stmt {
  if peak() == "if" {
    ignore expect(identifier);
    return ParseIfStmt();
  } else if peak() == "var" {
    ignore expect(identifier);
    let name: Token = expect(identifier);
    ignore expect(colon);
    let type: TypeRef = ParseTypeRef();
    if peak() == open_paran {
      return new VarCallStmt {
        name = name;
        type = type;
        ignore expect(open_paran);
        args = comma_array(Expr, comma, close_paran) { return ParseExpr(); };
        ignore expect(close_paran);
        ignore expect(semi);
      };
    } else if peak() == equal {
      return new VarAssignStmt {
        name = name;
        type = type;
        ignore expect(equal);
        value = ParseExpr();
        ignore expect(semi);
      };
    }
    return new VarStmt {
      name = name;
      type = type;
      ignore expect(semi);
    };
  } else if peak() == "loop" {
    ignore expect(identifier);
    return new LoopStmt {
      body = ParseCompoundStmt();
    };
  } else if peak() == "break" {
    ignore expect(identifier);
    return new BreakStmt{
      ignore expect(semi);
    };
  } else if peak() == "return" {
    ignore expect(identifier);
    return new ReturnStmt {
      expr = ParseExpr();
      ignore expect(semi);
    };
  } else {
    return new DiscardStmt {
      expr = ParseExpr();
      ignore expect(semi);
    };
  }
}

raw_func ParseCompoundStmt() -> Stmt {
  return new CompoundStmt {
    ignore expect(open_brace);
    stmts = concat_array(Stmt, close_brace) {
      return ParseStmt();
    };
    ignore expect(close_brace);
  };
}

raw_func ParseTypeRef() -> TypeRef {
  let result: TypeRef = new NamedTypeRef {
    name = expect(identifier);
  };
  if peak() == open_arr {
    return new TemplateTypeRef {
      base = result;
      ignore expect(open_arr);
      args = comma_array(TypeRef, comma, close_arr) { return ParseTypeRef(); }; 
      ignore expect(close_arr);
    };
  }
  return result;
}

raw_func ParseFuncArg() -> FuncArg {
  return new FuncArg {
    name = expect(identifier);
    ignore expect(colon);
    type = ParseTypeRef();
  };
}

raw_func ParseDecl() -> Decl {
  if peak() == "inline_cpp" {
    return new InlineCppDecl {
      ignore expect(identifier);
      ignore expect(open_paran);
      value = expect(str);
      ignore expect(close_paran);
      ignore expect(semi);
    };
  } else if peak() == "known_cpp_type" {
    return new KnownCppTypeDecl {
      ignore expect(identifier);
      name = expect(identifier);
      ignore expect(equal);
      value = expect(str);
      ignore expect(semi);
    };
  } else if peak() == "fn_expr" {
    return new FnExprDecl {
      ignore expect(identifier);
      name = expect(identifier);
      ignore expect(equal);
      items = concat_array(FnExprItem, semi) {
        return ParseFnExprItem();
      };
      ignore expect(semi);
    };
  } else if peak() == "known_template" {
    return new KnownTemplateDecl {
      ignore expect(identifier);
      name = expect(identifier);
      ignore expect(semi);
    };
  } else if peak() == "raw_func" {
    return new RawFuncDecl {
      ignore expect(identifier);
      name = expect(identifier);
      ignore expect(open_paran);
      args = comma_array(FuncArg, comma, close_paran) { return ParseFuncArg(); };
      ignore expect(close_paran);
      if peak() == arrow {
        ignore expect(arrow);
        ret_t = ParseTypeRef();
      } else {
        ret_t = new VoidTypeRef {};
      }
      body = ParseCompoundStmt();
    };
  }
  unexpected();
}

raw_func DoParse() -> Module {
  return new Module {
    decls = concat_array(Decl, eof) { return ParseDecl(); };
  };
}
